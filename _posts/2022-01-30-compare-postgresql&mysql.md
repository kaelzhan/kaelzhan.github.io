---
layout: post
title: Postgresql 与 Mysql 差异对比
subtitle: "Compare Postgresql with Mysql"
author: "kaelzhan"
header-img: "img/home/bg-2019.jpg"
header-mask: 0.3
mathjax: true
date: 2020-06-23
categories: DB
tags: [Database,Postgresql,Mysql]
description: The difference between Postgresql and Mysql
catalog: true
---

# Difference in data type

<table>
    <tr>
        <td><b>Data type</b></td>
        <td><b>MySQL</b></td>
        <td><b>PostgreSQL</b></td>
        <td><b>Comments</b></td>
    </tr>
    <tr>
        <td rowspan="4">Signed integer</td>
        <td>TINYINT</td>
        <td>SMALLINT</td>
        <td rowspan="4">integer size in PostgreSQL is 4 Bytes signed (-2147483648 – +2147483647)</td>
    </tr>
    <tr>
        <td>SMALLINT</td>
        <td>SMALLINT</td>
    </tr>
    <tr>
        <td>MEDIUMINT</td>
        <td>INTEGER</td>
    </tr>
    <tr>
        <td>BIGINT</td>
        <td>BIGINT</td>
    </tr>
    <tr>
        <td rowspan="5">Unsigned integer</td>
        <td>TINYINT UNSIGNED</td>
        <td>SMALLINT</td>
        <td rowspan="5">PostgresSQL doesn't know UNSIGNED, all numbers are signed.</td>
    </tr>
    <tr>
        <td>SMALLINT UNSIGNED</td>
        <td>INTEGER</td>
    </tr>
    <tr>
        <td>MEDIUMINT UNSIGNED</td>
        <td>INTEGER</td>
    </tr>
    <tr>
        <td>INT UNSIGNED</td>
        <td>BIGINT</td>
    </tr>
    <tr>
        <td>BIGINT UNSIGNED</td>
        <td>NUMERIC(20)</td>
    </tr>
    <tr>
        <td rowspan="2">Float</td>
        <td>FLOAT</td>
        <td>REAL</td>
        <td rowspan="2"></td>
    </tr>
    <tr>
        <td>FLOAT UNSIGNED</td>
        <td>REAL</td>
    </tr>
    <tr>
        <td>Double</td>
        <td>DOUBLE</td>
        <td>DOUBLE PRECISION</td>
        <td></td>
    </tr>
    <tr>
        <td>Boolen</td>
        <td>BOOLEAN</td>
        <td>BOOLEAN</td>
        <td>MySQL Booleans are an alias for TINYINT(1); PostgreSQL doesn't auto-convert numbers into booleans.</td>
    </tr>
    <tr>
        <td rowspan="4">Text</td>
        <td>TINYTEXT</td>
        <td>TEXT</td>
        <td rowspan="4"></td>
    </tr>
    <tr>
        <td>TEXT</td>
        <td>TEXT</td>
    </tr>
    <tr>
        <td>MEDIUMTEXT</td>
        <td>TEXT</td>
    </tr>
    <tr>
        <td>LONGTEXT</td>
        <td>TEXT</td>
    </tr>
    <tr>
        <td rowspan="6">Binary</td>
        <td>BINARY(n)</td>
        <td>BYTEA</td>
        <td rowspan="6"></td>
    </tr>
    <tr>
        <td>VARBINARY(n)</td>
        <td>BYTEA</td>
    </tr>
    <tr>
        <td>TINYBLOB</td>
        <td>BYTEA</td>
    </tr>
    <tr>
        <td>BLOB</td>
        <td>BYTEA</td>
    </tr>
    <tr>
        <td>MEDIUMBLOB</td>
        <td>BYTEA</td>
    </tr>
    <tr>
        <td>LONGBLOB</td>
        <td>BYTEA</td>
    </tr>
    <tr>
        <td>Fill 0</td>
        <td>ZEROFILL</td>
        <td>not available</td>
        <td></td>
    </tr>
    <tr>
        <td rowspan="4">Date</td>
        <td>DATE</td>
        <td>DATE</td>
        <td rowspan="4"></td>
    </tr>
    <tr>
        <td>TIME</td>
        <td>TIME [WITHOUT TIME ZONE] </td>
    </tr>
    <tr>
        <td>DATETIME</td>
        <td>TIMESTAMP [WITHOUT TIME ZONE]</td>
    </tr>
    <tr>
        <td>TIMESTAMP</td>
        <td>TIMESTAMP [WITHOUT TIME ZONE]</td>
    </tr>
    <tr>
        <td>Serial

value</td>
        <td> `column SERIAL` <br> equals to: <br> `column BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE`  <br> <br> or: <br> `column INT DEFAULT SERIAL` <br> equals to: <br> `column INT NOT NULL AUTO_INCREMENT UNIQUE`</td>
        <td>`column SERIAL` <br> equals to: <br> `CREATE SEQUENCE name;` <br> `CREATE TABLE table (` <br> &emsp;&emsp;`column INTEGER NOT NULL` <br> &emsp;&emsp;`DEFAULT nextval(name)` <br> `);`</td>
        <td>Note for PostgresSQL: <br> SERIAL = 1 – 2147483647 <br> BIGSERIAL = 1 – 9223372036854775807 <br> SERIAL is in fact an entity named SEQUENCE. It exists independently on the rest of your table. If you want to cleanup your system after dropping a table, you also have to DROP SEQUENCE name. More on that topic... <br><br> Note for MySQL: <br> `column SERIAL PRIMARY KEY` <br> or <br> `column SERIAL,` <br> `PRIMARY KEY(column)` <br> Will result in having 2 indexes for column. One will be generated by the PRIMARY KEY constraint, and one by the implicit UNIQUE constraint present in the SERIAL alias. This has been reported as a bug and might be corrected.</td>
    </tr>
    <tr>
        <td>Enumeration 

type</td>
        <td>`column ENUM (value1, value2, [...])`</td>
        <td>`column VARCHAR(255) NOT NULL,` <br> `CHECK (column IN (value1, value2, [...]))` <br> or <br> `CREATE TYPE mood AS ENUM ('sad','ok','happy');` <br> `CREATE TABLE person ( current_mood mood ... )`</td>
        <td>PostgreSQL doesn't have the ENUM types prior to 8.3, so you need to simulate it with constraints when using < 8.3.</td>
    </tr>
</table>

# Difference in transaction

### About DDL rollback

PostgreSQL supports `DDL ROLLBACK` in addition to the regular `DML ROLLBACK`, Such as the `ROLLBACK` of `CREATE TABLE`，`TRUNCATE`.

```sql
select count(*) from sys_user;
Suppose there are 9 data returned

BEGIN;

TRUNCATE sys_user;

select count(*) from sys_user;
There are 0 data returned

ROLLBACK;

select count(*) from sys_user;
Still return 9 data
```

# Difference in syntax
### About schema

A special place of Postgresql compared to Mysql is that there is another thing under its database called: `schema`, by default there is a `public` schema in each database.  
PostgreSQL supports multiple `schema`, but `public` is recommended, because it's the default `schema`, this can be omitted when writing query SQL, which is convenient for the system to do database migration in the future.  

### About index name

When creating an index, MySQL only needs to have a unique index name in the same table, but PostgreSQL must be unique throughout the database.

### About symbol

PostgreSQL does not support the use of \` to wrap table names, field names, etc.
| Usage | MySQL | PostgreSQL | comments |
|:--|:--|:--|:--|
| Comment | # | -- | MySQL accepts nonstandard # to begin a comment line; PostgreSQL uses ANSI standard double dash; use the ANSI standard, both databases understand it. (However, MySQL requires a space after --, whilst it is not mandatory in PostgreSQL) |
| value quote | ' " | \' | 	MySQL uses \' or \" to quote values (i.e. WHERE name = "John"). This is not the ANSI standard for databases. PostgreSQL uses only single quotes for this (i.e. WHERE name = 'John').  Note: you can make MySQL interpret quotes like PostgreSQL using SET sql_mode='ANSI_QUOTES'. |
| system identifiers quote | \` | \" | MySQL uses \` (accent mark or backtick) to quote system identifiers, which is decidedly non-standard. In PostgreSQL, double quotes are used to quote system identifiers; field names, table names, etc. (i.e. WHERE "last name" = 'Smith'). Also, you can make MySQL interpret quotes like PostgreSQL using SET sql_mode='ANSI_QUOTES'. |
| case-sensitive | ```` `LastName` = `lastname` ```` <br> and maybe not? | `"LastName" <> "lastname"` | Database, table, field and columns names in PostgreSQL are case-independent, unless you created them with double-quotes around their name, in which case they are case-sensitive. In MySQL, table names can be case-sensitive or not, depending on which operating system you are using. Note that PostgreSQL actively converts all non-quoted names to lower case and so returns lower case in query results! |
| OR | `'foo' `\|\|` 'bar'` <br> means OR | `'foo' `\|\|` 'bar'` <br> means string concatenation (= 'foobar') | MySQL accepts C-language operators for logic, SQL requires AND, OR; use the SQL standard keywords for logic, both databases understand it. |

### About SQL

<table>
    <tr>
        <td><b>Type</b></td>
        <td><b>MySQL</b></td>
        <td><b>PostgreSQL</b></td>
        <td><b>Comments</b></td>
    </tr>
    <tr>
        <td rowspan="6">
        
Update</td>
        <td>`UPDATE films SET kind = 'Dramatic' WHERE kind = 'Drama';`</td>
        <td>`UPDATE films SET kind = 'Dramatic' WHERE kind = 'Drama';`</td>
        <td>Single table update</td>
    </tr>
    <tr>
        <td>`UPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT WHERE city = 'San Francisco' AND date = '2003-07-03';`</td>
        <td>`UPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT WHERE city = 'San Francisco' AND date = '2003-07-03';`</td>
        <td>Update multiple fields in a single table</td>
    </tr>  
    <tr>
        <td>**`SELECT temp_lo, temp_hi, prcp FROM UPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT WHERE city = 'San Francisco' AND date = '2003-07-03';`**</td>
        <td>**`UPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT WHERE city = 'San Francisco' AND date = '2003-07-03' RETURNING temp_lo, temp_hi, prcp;`**</td>
        <td>**Update and return**</td>
    </tr>
    <tr>
        <td>`UPDATE employees SET sales_count = sales_count+1 WHERE accounts.name = 'Acme Corporation' AND employees.id = accounts.sales_person;`</td>
        <td>`UPDATE employees SET sales_count = sales_count+1 WHERE accounts.name = 'Acme Corporation' AND employees.id = accounts.sales_person;`</td>
        <td rowspan="2">Table association update</td>
    </tr>
    <tr>
        <td>`UPDATE employees SET sales_count = sales_count+1 WHERE id = (SELECT sales_person FROM accounts WHERE name = 'Acme Corporation');`</td>
        <td>`UPDATE employees SET sales_count = sales_count+1 WHERE id = (SELECT sales_person FROM accounts WHERE name = 'Acme Corporation');`</td>
    </tr>
    <tr>
        <td>**-**</td>
        <td>**`UPDATE accounts SET (contact_last_name,contact_first_name) = (SELECT last_name,first_name FROM salesmen WHERE salesmen.id = accounts.sales_id);`**</td>
        <td>**Multi-field update of table association**</td>
    </tr>
    <tr>
        <td rowspan="7">Insert</td>
        <td>`INSERT INTO films VALUES ('UA502', 'Bananas', 105, '1971-07-13', 'Comedy', '82 Minutes');`</td>
        <td>`INSERT INTO films VALUES ('UA502', 'Bananas', 105, '1971-07-13', 'Comedy', '82 Minutes');`</td>
        <td>Insert a single line</td>
    </tr>
    <tr>
        <td>`INSERT INTO films (code, title, did, date_prd, kind) VALUES ('UA502', 'Bananas', 105, '1971-07-13', 'Comedy');`</td>
        <td>`INSERT INTO films (code, title, did, date_prd, kind) VALUES ('UA502', 'Bananas', 105, '1971-07-13', 'Comedy');`</td>
        <td>Insert specified field</td>
    </tr>
    <tr>
        <td>`INSERT INTO films (code, title, did, date_prd, kind) VALUES ('UA502', 'Bananas', 105, '1971-07-13', 'Comedy'), ('HG120', 'The Dinner Game', 140, DEFAULT, 'Comedy');`</td>
        <td>`INSERT INTO films (code, title, did, date_prd, kind) VALUES ('UA502', 'Bananas', 105, '1971-07-13', 'Comedy'), ('HG120', 'The Dinner Game', 140, DEFAULT, 'Comedy');`</td>
        <td>Insert multiple rows</td>
    </tr>
    <tr>
        <td>**-**</td>
        <td>**`INSERT INTO distributors (did,dname) VALUES (DEFAULT,’XYZ’) RETURNING did;`**</td>
        <td>**Insert and return**</td>
    </tr>
    <tr>
        <td>**`INSERT INTO distributors (did,dname) VALUES (5, 'Gizmo'), (6, 'Associated Computing, Inc') ON DUPLICATE KEY UPDATE dname =  EXCLUDED.dname;`**</td>
        <td>**`INSERT INTO distributors (did,dname) VALUES (5, 'Gizmo'), (6, 'Associated Computing, Inc') ON CONFLICT (did) DO UPDATE SET dname = EXCLUDED.dname;`**</td>
        <td>**Update when insert conflict**</td>
    </tr>
    <tr>
        <td>**`INSERT IGNORE INTO distributors (did, dname) VALUES (9, 'Design');`**</td>
        <td>**`INSERT INTO distributors (did, dname) VALUES (9, 'Design') ON CONFLICT ON CONSTRAINT distributors_pkey DO NOTHING;`**</td>
        <td>**Do nothing when insert conflict**</td>
    </tr>  
    <tr>
        <td>**`REPLACE INTO t (id, update_time) VALUES (1, now())`**</td>
        <td>**-**</td>
        <td>**Update if exist**</td>
    </tr>
    <tr>
        <td rowspan="2">Delete</td>
        <td>`DELETE FROM films WHERE producer_id IN (SELECT id FROM producers WHERE name = 'foo')`</td>
        <td>`DELETE FROM films WHERE producer_id IN (SELECT id FROM producers WHERE name = 'foo')`</td>
    </tr> 
    <tr>
        <td>**-**</td>
        <td>**`DELETE FROM tasks WHERE status = 'DONE' RETURNING *;`**</td>
        <td>**Delete and return**</td>
    </tr> 
    <tr>
        <td rowspan="10">Index</td>
        <td>**`ALTER TABLE table_name ADD INDEX index_name (column_list);`**</td>
        <td>**-**</td>
    </tr> 
    <tr>
        <td>**`ALTER TABLE table_name ADD UNIQUE (column_list);`**</td>
        <td>**-**</td>
    </tr> 
    <tr>
        <td>**`ALTER TABLE table_name ADD PRIMARY KEY (column_list);`**</td>
        <td>**-**</td>
    </tr> 
    <tr>
        <td>`CREATE INDEX index_name ON table_name (column_list);`</td>
        <td>`CREATE INDEX index_name ON table_name (column_list);`</td>
    </tr> 
    <tr>
        <td>`CREATE UNIQUE INDEX index_name ON table_name (column_list);`</td>
        <td>`CREATE UNIQUE INDEX index_name ON table_name (column_list);`</td>
    </tr>
    <tr>
        <td>`DROP INDEX index_name ON table_name;`</td>
        <td>`DROP INDEX index_name ON table_name;`</td>
    </tr> 
    <tr>
        <td>**`ALTER TABLE table_name DROP INDEX index_name;`**</td>
        <td>**-**</td>
    </tr> 
    <tr>
        <td>**`ALTER TABLE table_name DROP primary key;`**</td>
        <td>**-**</td>
    </tr> 
    <tr>
        <td>**-**</td>
        <td>**`CREATE UNIQUE INDEX CONCURRENTLY dist_id_temp_idx ON distributors (dist_id);`**</td>
        <td rowspan="2">Parallel index build</td>
    </tr> 
    <tr>
        <td>**-**</td>
        <td>**`CREATE INDEX CONCURRENTLY dist_id_temp_idx ON distributors (dist_id);`**</td>
    </tr>  
</table>

### About create table
#### Create table with mysql

```sql
DROP TABLE IF EXISTS sys_user;

CREATE TABLE sys_user
(
    id                   bigint      NOT NULL COMMENT 'Primary key ID',
    username             varchar(50) NOT NULL COMMENT 'User account:oneParam',
    real_name            varchar(50) NULL COMMENT 'Real Name',
    user_password        varchar(50) NOT NULL COMMENT 'Password',
    user_email           varchar(50) NULL COMMENT 'Email:oneParam',
    mobile_phone         varchar(20) NULL COMMENT 'Mobile:oneParam',
    gender_enum          tinyint     NOT NULL DEFAULT '1' COMMENT 'Gender:[1=PRIVACY, 2=MALE, 3=FEMALE, 4=NEUTRAL]max=4',
    create_date          bigint      NOT NULL COMMENT 'Create date',
    create_user_id       bigint      NOT NULL COMMENT 'Create user',
    update_date          bigint      NOT NULL COMMENT 'Update date',
    update_user_id       bigint      NOT NULL COMMENT 'Update user',
    delete_date          bigint      NULL COMMENT 'Delete date',
    delete_user_id       bigint      NULL COMMENT 'Delete user',
    PRIMARY KEY (id)
) COMMENT ='User table';
```

#### Create table with postgresql
```sql
DROP TABLE IF EXISTS sys_user;

CREATE TABLE sys_user
(
    id                   bigint      NOT NULL,
    username             varchar(50) NOT NULL,
    real_name            varchar(50) NULL,
    user_password        varchar(50) NOT NULL,
    user_email           varchar(50) NULL,
    mobile_phone         varchar(20) NULL,
    gender_enum          smallint    NOT NULL,
    create_date          bigint      NOT NULL,
    create_user_id       bigint      NOT NULL,
    update_date          bigint      NOT NULL,
    update_user_id       bigint      NOT NULL,
    delete_date          bigint      NULL,
    delete_user_id       bigint      NULL,
    PRIMARY KEY (id)
)
WITH (
    OIDS = FALSE
);

COMMENT ON TABLE sys_user IS 'User table';
COMMENT ON COLUMN sys_user.id IS 'Primary key ID';
COMMENT ON COLUMN sys_user.username IS 'User account:oneParam';
COMMENT ON COLUMN sys_user.real_name IS 'Real Name';
...
```



